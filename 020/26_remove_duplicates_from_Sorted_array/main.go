/* https://leetcode.com/problems/remove-duplicates-from-sorted-array/

Учитывая целочисленный массив nums, отсортированный в порядке неубывания, удалите дубликаты на месте таким образом,
чтобы каждый уникальный элемент появлялся только один раз. Относительный порядок элементов должен оставаться неизменным.
Поскольку в некоторых языках невозможно изменить длину массива, вместо этого вы должны поместить результат в первую часть массива nums.
Более формально, если после удаления дубликатов осталось k элементов, то первые k элементов nums должны содержать конечный результат.
Не имеет значения, что вы оставляете за пределами первых k элементов.
Верните k после размещения конечного результата в первых k слотах nums.

Не выделяйте дополнительное пространство для другого массива.
Вы должны сделать это, изменив входной массив на месте с помощью O(1) дополнительной памяти.

Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Объяснение: Ваша функция должна возвращать k = 2, причем первые два элемента nums равны 1 и 2 соответственно.
Не имеет значения, что вы оставляете за пределами возвращаемого k (следовательно, они являются символами подчеркивания).

Выполнено:
Время выполнения: 6 мс, быстрее, чем 92,45% отправок в режиме онлайн для удаления дубликатов из отсортированного массива.
Использование памяти: 4,3 МБ, менее 82,08% отправленных онлайн-заявок на удаление дубликатов из отсортированного массива.
*/

package main

import "fmt"

func main() {
	nums := []int{-1, 0, 0, 1, 1, 1, 2, 2, 3, 3, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 8, 8, 9, 10, 11, 12, 13, 13, 13, 14}
	k := removeDuplicates(nums)
	fmt.Println(nums)
	fmt.Println(nums[:k])
	fmt.Println("k =", k)
}

func removeDuplicates(nums []int) int {
	var idx int
	for i := 1; i < len(nums); i++ {
		if nums[i-1] != nums[i] {
			idx++
			nums[idx] = nums[i]
		}
	}
	return idx
}

func removeDuplicates1(nums []int) int {
	k := len(nums)
	idx := 0
	for i, d := range nums {
		if i == 0 {
			idx++
			continue
		}
		if nums[i-1] == d {
			k--
			continue
		}
		nums[idx] = d
		idx++
	}
	return k
}
